			+--------------------+
			|        CS 2042      |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- PRELIMINARIES ----

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff. If you fail to do so while your
>> soltion contains such material you will be penalized.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In thread.h file, 
int64_t waketick; was added to keep track of the waiting time while the thread is sleeping.

bool compare_waketick(const struct list_elem *first, const struct list_elem *second, void *aux);
//This was added to compare two threads by their waketick;

---------------------------------------

In timer.c file,
struct list sleep_list; was added to keep a list of sleeping threads

void timer_sleep (int64_t ticks) {}; implementation was changed, so that busy waiting is removed.
Now the thread will be inserted to the sleep_list (In sort order) and thread will be blocked.

static void timer_interrupt (struct intr_frame *args UNUSED){}; implementation was changed, so that,
when the waketick is expired the sleeping thread will be removed and unblocked and pushed to the ready_list.


---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

When it is called, the waketick value will be calculated and the thread will be put into the
sleeping_list (in sorting order), then the thread will be blocked.
In interrupt_handler, waketick expired threads will be removed from the sleep_list, unblock them and
pushed those threads back to ready list.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

1) When threads are inserted to the sleep_list they are inserted in the
sorting order (lowest waketick threads first). So that when interrupt_handler check
for expired threads, it only has to remove the elements from the front of the sleep_list.
This is more efficient than iterating the whole sleep_list.

2) While removing elements from the front of the list, the loop will break once
all the expired waketick threads are removed, thus reducing time spent in interrupt_handler.

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

Interrupts are disabled while the waketick is calculated and put into sleep_list.
So race conditions will not occur.

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

Interrupts are off in timer_sleep().

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

This design is efficient because busy waiting has been avoided.
Also, implementation is easy, since list inserts have been provided.

			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In thread.h file,

struct list donators; //keep track of donor thread list (Threads that can donate priority to this thread)
struct list_elem d_element; //keep track of donors list element
int original_priority; //This will store the original priority of thread
bool compare_thread_priorities (const struct list_elem *a,const struct list_elem *b,void *aux);//This will
compare two threads based on their priority.

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

struct list donators;
This list is used to keep track of the donors of a thread. Suppose T1 has acquired a lock.
T2 and T3 is waiting to acquire the same lock. So T2 and T3 is added to this list 
(In order where highest priority thread is at front. This list is inside T1.).
When the lock is released by T1, T2 and T3 will be removed from this list.

Nested Donation (Not implemented in this lab)
    Assume Thread T1 with original priority 31 and thread T2 with original priority 32.
    and T1 have acquired lock L1 and T2 have acquired lock L2.
	(T1 priority < T2 priority < T3 priority)

    What if T2 try to acquire lock L1?
	Then the priority of T2 will be temporarily chanegd to 32 (priority of T2).

         temporary_priority: 32   
        --------                 --------       
        |Thread T1|  waits for L1 |Thread T2|  
        |pri: 32  | <------------ |pri: 32  | 
        |locks: L1|               |locks: L2|  
        --------                 --------       


	 What if a new thread T3 with a priority of 33 wants to acquire lock L2?
	 Now, the priority of T2 will be changed to 33 (priority of T3).
	 And then, the priority of T1 will also be changed to 33 (priority of T3).



        temporary_priority: 33    temporary_priority: 33  temporary_priority: 33
         --------                 --------                 --------
        |Thread T1|  waits for L1|Thread T2|  waits for L2|Thread T3|
        |pri: 33 | <------------ |pri: 33  | <------------|pri: 33  |
        |locks: L1|              |locks: L2|              |         |
         --------                 --------                 --------

    This is called the nested donation.

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

When inserting threads to waiting lists, do that in sorting order where
highest priority thread is at the front. And pop the first element when needed.

Lock - lock->semaphore->waiters
Semaphore - semaphore->waiters
Condition - condition->waiters

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

When lock_acquire is called, if that lock already has a holder, then the current_thread
will be inserted o the donators_list of holder. Now, if the prority of holder is lower than
the maximum priority of donators_list, that maximum priority will be assigned as the holder priority.

//Nested donation has not been handled in this lab.

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

1) The threads that acted as donors when the lock was acquired, will be removed from the donators_list
of the current_thread.
2) Now, the highest_priority thread from the donators_list will be set as the new priority of
the current_thread if (lock->holder->donators_list is not empty). (This means this thread has
acquired other locks. So the threads that are waiting for these locks can still donate priority
 to the current_thread)
3) if (lock->holder->donators_list is empty), that means this thread has not any acquired locks.
So there are no threads to donate priority to this thread. In this case original_priority is set
 as the priority.
4) then lock->holder is set to as null and sema_up() is called.
5) In sema_up(), the highest_priority waiting thread is selected and unblocked.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

When thread_set_priority() is called, the priority of the thread will be changed.
But suppose, the priority of that thread has been temporarily changed by a donor.
In this case, if it is not checked, can cause problems in priorities.

Changed the implementation as follows,
	when thread_set_priority() is called, set it as the thread->original_priority.
	Then, check whether there are any donors with a priority higher than the given priority.
	If there is such a thread, set thread->priority = (donor with highest priority)->priority.
	Otherwise, thread->priority = thread->original_priority

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

This design is easy to implement and simple. Also it is easy to maintain a list of donors,
so we can easily handle priority donations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts. You may also
choose to respond anonymously in the course evaluations at the end of
the semester.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future semesters or the remaining projects?

>> Any other comments?